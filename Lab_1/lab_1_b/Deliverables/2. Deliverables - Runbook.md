
### **Part 2: Incident Response Operations

Incident Title: Production Database Connectivity Timeout

Timestamp of Failure: 12:02 PM EST

Scenario: Application reported connection failures; initial indicators suggested network isolation.

Evidence of Injection (Broken State):

(Security Group Rules showing missing MySQL rule)

> ![](attachment/0e8163abcf8fa1ee445859095ff4cbf6.png)
> 
> ![](attachment/300bb7c50b7439c239a2fa1a1e044a92.png)

#### **RUNBOOK SECTION 1 — Acknowledge**

1.1 Confirm Alert

Upon receiving the SNS notification email, I verified the alarm state via the CLI to confirm the system was in a breaching state.

**Evidence:** Email alarm notification received at 12:04 PM.

> ![](attachment/5ed3a0a197c402ff8303c44401532b2a.png)

- **Command:**
    
    Bash
    
    ```
    aws cloudwatch describe-alarms \
      --alarm-names lab-db-connection-failure \
      --query "MetricAlarms[].StateValue"
    ```
    
- **Result:** `ALARM`
    

**Evidence:** CLI output confirming alarm state.

> ![](attachment/49bed2ca344b4ecbe8558bb8ee9fc9c6.png)

#### **RUNBOOK SECTION 2 — Observe**

2.1 Check Application Logs

I queried the centralized CloudWatch logs to identify the specific error signature (DB_CONNECTION_FAILURE) associated with the alarm.

- **Command:**
    
    Bash
    
    ```
    aws logs filter-log-events \
      --log-group-name /aws/ec2/lab-rds-app \
      --filter-pattern "DB_CONNECTION_FAILURE"
    ```
    
- **Result:** The logs returned `(2003, "Can't connect to MySQL server on ... (timed out)")`.
    

Evidence: CLI output showing active error stream.

(Note the changing ingestion times, indicating new error messages were being generated).

> ![](attachment/3d8d32417c705511a4668114453dd108.png)

**2.2 Identify Failure Type**

- **Classification:** **Network / Security Group Failure**
    
- **Justification:** The log message explicitly states `timed out` (Error 2003).
    
    - If it were a **Credential** issue, the error would be `Access denied` (1045) because the DB would receive the request and reject it.
        
    - A **Timeout** indicates the request was sent but no response was received, which confirms the traffic is being silently dropped by a firewall (Security Group).
        

#### **RUNBOOK SECTION 3 — Validate Configuration Sources**

3.1 Retrieve Parameter Store Values

I verified that the application is attempting to connect to the correct RDS endpoint and port.

- **Command:**
    
    Bash
    
    ```
    aws ssm get-parameters \
      --names /lab/db/endpoint /lab/db/port /lab/db/name \
      --with-decryption
    ```
    
- **Result:** The correct Endpoint and Port (3306) were returned, ruling out a configuration drift.
    

**Evidence:** SSM Output from EC2.

> ![](attachment/acc1f6c5cc84892904b7a09ed8a2d045.png)

3.2 Retrieve Secrets Manager Values

I verified the credentials available to the application to ensure they hadn't been corrupted or deleted.

- **Command:**
    
    Bash
    
    ```
    aws secretsmanager get-secret-value --secret-id lab/rds/mysql
    ```
    
- **Result:** Valid JSON payload returned.
    

**Evidence:** Secrets Manager Output retrieved from Application EC2.

> ![](attachment/5788ae1a965f6a08812df0e6545ee7c2.png)

#### **RUNBOOK SECTION 4 — Containment**

**4.1 Prevent Further Damage**

- **Statement:** System state preserved for recovery. No EC2 restart, credential rotation, or infrastructure redeployment was initiated.
    

#### **RUNBOOK SECTION 5 — Recovery**

5.1 Execution (Remediation)

Having identified the root cause as a Network Block, I audited the RDS Security Group rules. I discovered the Inbound Rule for TCP Port 3306 was missing. I manually restored the rule to allow traffic from the EC2 Security Group.

**Evidence:** Security Group (Broken State).

> ![](attachment/300bb7c50b7439c239a2fa1a1e044a92.png)

**Evidence:** Security Group (Restored State).

> ![](attachment/ebc17dfa8f5d60571b34173905fe4057.png)

5.2 Verification

I verified application connectivity using the public endpoint.

- **Command:** `curl http://<EC2_PUBLIC_IP>/list`
    
- **Result:** The application returned the expected JSON list, indicating the connection to the database was restored.
    

**Evidence:** Functioning webpage after recovery.

> ![](attachment/9ba02b5a3a7fff8a1e7cbb2de8c9ad7b.png)

#### **RUNBOOK SECTION 6 — Post-Incident Validation**

6.1 Confirm Alarm Clears

I monitored the alarm state to ensure it automatically resolved once the errors stopped.

- **Command:**
    
    Bash
    
    ```
    aws cloudwatch describe-alarms \
      --alarm-name lab-db-connection-failure \
      --query "MetricAlarms[].StateValue"
    ```
    
- **Result:** `OK`
    

**Evidence:** CLI command showing Alarm state OK.

> ![](attachment/1553a8ebbe923b72df58dce4cb271be0.png)

**Evidence**: CloudWatch Alarm in console, showing recovered state:
>![](attachment/185da3314c418631571cad595671e32b.png)


**6.2 Confirm Logs Normalize**

- **Command:** `aws logs filter-log-events ...`
    
- **Result:** No new error logs generated after the fix timestamp.
    

Evidence: CLI output of log filtering.

(Note the ingestion times are static for the last error messages, confirming no new errors are being sent).

> ![](attachment/5693050ac4509c929bab681259754cef.png)

---
